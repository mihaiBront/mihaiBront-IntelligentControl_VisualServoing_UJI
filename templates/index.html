<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=3.0">
    <title>IBVS Training Monitor</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        /* CSS Variables for theming */
        :root {
            --bg-primary: #f3f4f6;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f9fafb;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --text-tertiary: #6b7280;
            --border-color: #e5e7eb;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --accent-color: #be1b54;
            --success-color: #059669;
            --error-color: #dc2626;
            --warning-color: #d97706;
        }

        [data-theme="dark"] {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --border-color: #4b5563;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --accent-color: #de44ab;
            --success-color: #10b981;
            --error-color: #ef4444;
            --warning-color: #f59e0b;
        }

        .card {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px var(--shadow-color), 0 2px 4px -1px var(--shadow-color);
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
        }

        @media (min-width: 768px) {
            .card {
                padding: 1.5rem;
                margin-bottom: 1.5rem;
            }
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        @media (min-width: 768px) {
            .card-title {
                font-size: 1.25rem;
                margin-bottom: 1rem;
            }
        }

        .metric {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
            line-height: 1.2;
        }

        @media (min-width: 768px) {
            .metric {
                font-size: 1.875rem;
            }
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        @media (min-width: 768px) {
            .metric-label {
                font-size: 0.875rem;
            }
        }

        .model-name {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-primary);
            text-transform: uppercase;
            line-height: 1.2;
        }

        @media (min-width: 768px) {
            .model-name {
                font-size: 2.25rem;
            }
        }

        .model-status {
            font-size: 0.875rem;
            color: var(--success-color);
            margin-top: 0.25rem;
        }

        @media (min-width: 768px) {
            .model-status {
                font-size: 1rem;
            }
        }

        /* Mobile-specific optimizations */
        @media (max-width: 767px) {
            .mobile-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0.75rem;
            }
            
            .mobile-full {
                grid-column: 1 / -1;
            }
            
            .config-section {
                margin-bottom: 1.5rem;
            }
            
            .config-section:last-child {
                margin-bottom: 0;
            }
        }

        /* Touch-friendly buttons and interactions */
        .touch-friendly {
            min-height: 44px;
            min-width: 44px;
        }

        /* Plotly mobile optimizations */
        .plotly-container {
            height: 300px;
        }

        @media (min-width: 768px) {
            .plotly-container {
                height: 400px;
            }
        }

        /* Prevent text selection on mobile for better UX */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Print-specific styles for PDF generation */
        @media print {
            /* Reset page margins and setup */
            @page {
                margin: 0.5in;
                size: A4;
            }

            /* Remove background colors and shadows for print */
            body {
                background: white !important;
                color: black !important;
                font-size: 12pt;
                line-height: 1.4;
                padding: 0 !important;
                margin: 0 !important;
            }

            /* Card styling for print */
            .card {
                background: white !important;
                box-shadow: none !important;
                border: 1px solid #ccc !important;
                border-radius: 4px !important;
                padding: 12pt !important;
                margin-bottom: 16pt !important;
                page-break-inside: avoid;
            }

            /* Typography adjustments */
            h1 {
                font-size: 18pt !important;
                margin-bottom: 12pt !important;
                color: black !important;
                page-break-after: avoid;
            }

            .card-title {
                font-size: 14pt !important;
                margin-bottom: 8pt !important;
                color: black !important;
                page-break-after: avoid;
            }

            .model-name {
                font-size: 16pt !important;
                color: black !important;
                margin-bottom: 4pt !important;
            }

            .model-status {
                font-size: 10pt !important;
                color: #333 !important;
                margin-bottom: 8pt !important;
            }

            /* Metrics grid for print */
            .metric {
                font-size: 14pt !important;
                color: black !important;
                font-weight: bold !important;
            }

            .metric-label {
                font-size: 9pt !important;
                color: #555 !important;
                margin-top: 2pt !important;
            }

            /* Grid layouts for print */
            .grid {
                display: grid !important;
                gap: 8pt !important;
            }

            .grid-cols-2 {
                grid-template-columns: 1fr 1fr !important;
            }

            .grid-cols-3 {
                grid-template-columns: 1fr 1fr 1fr !important;
            }

            .lg\\:grid-cols-6 {
                grid-template-columns: repeat(6, 1fr) !important;
            }

            .lg\\:grid-cols-2 {
                grid-template-columns: 1fr 1fr !important;
            }

            /* Configuration sections */
            .config-section h3 {
                font-size: 12pt !important;
                color: black !important;
                margin-bottom: 6pt !important;
            }

            .config-section div {
                background: #f8f8f8 !important;
                border: 1px solid #ddd !important;
                padding: 8pt !important;
                border-radius: 2px !important;
                font-size: 9pt !important;
            }

            /* Configuration text elements */
            .config-section span {
                color: black !important;
            }

            /* Plot containers for print */
            .plotly-container {
                height: 250pt !important;
                width: 100% !important;
                page-break-inside: avoid;
                margin-bottom: 8pt !important;
            }

            /* Performance metrics grid */
            .lg\\:grid-cols-2 .plotly-container {
                height: 200pt !important;
            }

            /* Hide interactive elements that don't work in print */
            .modebar,
            .plotly-modebar {
                display: none !important;
            }

            /* Ensure plots are visible in print */
            .js-plotly-plot .plotly {
                background: white !important;
            }

            .js-plotly-plot .bg {
                fill: white !important;
            }

            /* Mermaid diagram print styles */
            .mermaid-diagram {
                page-break-inside: avoid;
                margin: 8pt 0 !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                min-height: 200pt !important;
                background: white !important;
                border: 1px solid #ddd !important;
                padding: 8pt !important;
            }

            .mermaid-diagram svg {
                background: white !important;
                max-width: 100% !important;
                height: auto !important;
                max-height: 600pt !important;
                border: none !important;
                box-shadow: none !important;
                font-family: "Arial", sans-serif !important;
                font-size: 10pt !important;
            }

            /* Ensure Mermaid text is readable in print */
            .mermaid-diagram svg text {
                fill: black !important;
                font-size: 9pt !important;
                font-family: "Arial", sans-serif !important;
            }

            /* Mermaid node styling for print */
            .mermaid-diagram svg .node rect,
            .mermaid-diagram svg .node circle,
            .mermaid-diagram svg .node ellipse,
            .mermaid-diagram svg .node polygon {
                stroke: black !important;
                stroke-width: 1pt !important;
                fill: white !important;
            }

            /* Mermaid edge styling for print */
            .mermaid-diagram svg .edgePath path {
                stroke: black !important;
                stroke-width: 1pt !important;
                fill: none !important;
            }

            /* Mermaid arrowheads for print */
            .mermaid-diagram svg .arrowheadPath {
                fill: black !important;
                stroke: black !important;
            }

            /* Force diagram to fit page width */
            .mermaid-diagram svg {
                width: 100% !important;
                height: auto !important;
            }

            /* Text formatting in config sections */
            .text-xs, .sm\\:text-sm {
                font-size: 9pt !important;
            }

            .text-sm {
                font-size: 10pt !important;
            }

            .text-base, .md\\:text-lg {
                font-size: 11pt !important;
            }

            /* Responsive classes override for print */
            .md\\:p-8 {
                padding: 0 !important;
            }

            .md\\:mb-8 {
                margin-bottom: 12pt !important;
            }

            .md\\:text-3xl {
                font-size: 18pt !important;
            }

            /* Page breaks */
            .card:nth-child(1) {
                page-break-before: avoid;
            }

            .card:nth-child(3) {
                page-break-before: auto;
            }

            /* Ensure content fits well */
            .break-all {
                word-break: break-word !important;
            }

            /* Color adjustments for better print contrast */
            .text-gray-700 {
                color: #333 !important;
            }

            .text-gray-900 {
                color: black !important;
            }

            .text-gray-800 {
                color: #222 !important;
            }

            /* Print timestamp */
            .card:last-child::after {
                content: "Generated: " attr(data-timestamp);
                display: block;
                font-size: 8pt;
                color: #666;
                margin-top: 8pt;
                text-align: right;
                border-top: 1px solid #ddd;
                padding-top: 4pt;
            }
        }

        /* Top Navigation Bar */
        .top-nav {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px var(--shadow-color);
            padding: 1rem 1.5rem;
            margin: -0.75rem -0.75rem 1.5rem -0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        @media (min-width: 768px) {
            .top-nav {
                margin: -2rem -2rem 2rem -2rem;
                padding: 1.25rem 2rem;
            }
        }

        .nav-title {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-primary);
            margin: 0;
        }

        @media (min-width: 768px) {
            .nav-title {
                font-size: 1.875rem;
            }
        }

        .nav-buttons {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .nav-button {
            background: var(--accent-color);
            color: var(--bg-secondary);
            border: none;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 4px var(--shadow-color);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .nav-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .nav-button.theme-toggle {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .nav-button.theme-toggle:hover {
            background: var(--border-color);
        }

        @media print {
            .top-nav {
                display: none !important;
            }
        }

        @media (max-width: 767px) {
            .nav-buttons {
                gap: 0.5rem;
            }
            
            .nav-button {
                padding: 0.5rem 0.75rem;
                font-size: 0.75rem;
            }
            
            .nav-button .button-text {
                display: none;
            }
            
            .nav-title {
                font-size: 1.25rem;
            }
        }

        /* History Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 1rem;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px var(--shadow-color), 0 10px 10px -5px var(--shadow-color);
            max-width: 800px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .modal-body {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .model-list {
            display: grid;
            gap: 1rem;
        }

        .model-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .model-item:hover {
            background: var(--border-color);
            transform: translateY(-1px);
            box-shadow: 0 4px 6px var(--shadow-color);
        }

        .model-item.active {
            border-color: var(--accent-color);
            background: var(--accent-color);
            color: var(--bg-secondary);
        }

        .model-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .model-item-name {
            font-weight: 600;
            font-size: 1rem;
        }

        .model-item-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            background: var(--success-color);
            color: white;
        }

        .model-item-status.training {
            background: var(--warning-color);
        }

        .model-item-details {
            font-size: 0.875rem;
            color: var(--text-secondary);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .model-item.active .model-item-details {
            color: rgba(255, 255, 255, 0.8);
        }

        @media print {
            .modal-overlay {
                display: none !important;
            }
        }

        /* Mermaid diagram styles */
        .mermaid-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .mermaid-diagram svg {
            max-width: 100%;
            height: auto;
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            font-family: 'Arial', sans-serif;
        }

        /* Ensure Mermaid text is always readable */
        .mermaid-diagram svg text {
            font-family: 'Arial', sans-serif;
            font-size: 12px;
        }

        /* Ensure good contrast for diagram elements */
        .mermaid-diagram svg .node rect,
        .mermaid-diagram svg .node circle,
        .mermaid-diagram svg .node ellipse,
        .mermaid-diagram svg .node polygon {
            stroke-width: 2px;
        }

        .mermaid-diagram svg .edgePath path {
            stroke-width: 2px;
        }

        @media (max-width: 767px) {
            .mermaid-diagram {
                padding: 0.5rem;
                min-height: 150px;
            }
            
            .mermaid-diagram svg {
                font-size: 10px;
            }

            .mermaid-diagram svg text {
                font-size: 10px;
            }
        }
    </style>
</head>

<body class="min-h-screen p-3 md:p-8" style="background-color: var(--bg-primary); color: var(--text-primary);">
    <!-- Top Navigation Bar -->
    <nav class="top-nav">
        <h1 class="nav-title">IBVS Training Monitor</h1>
        <div class="nav-buttons">
            <button class="nav-button" onclick="toggleHistoryModal()" title="View Model History">
                ðŸ“Š <span class="button-text">History</span>
            </button>
            <button class="nav-button theme-toggle" onclick="toggleTheme()" title="Toggle Dark/Light Theme">
                <span id="themeIcon">ðŸŒ™</span>
                <span id="themeText" class="button-text">Dark</span>
            </button>
            <button class="nav-button" onclick="printReport()" title="Print/Save as PDF">
                ðŸ“„ <span class="button-text">Print PDF</span>
            </button>
        </div>
    </nav>

    <!-- History Modal -->
    <div id="historyModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Model Training History</h2>
                <button class="modal-close" onclick="toggleHistoryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="modelList" class="model-list">
                    <div class="text-center" style="color: var(--text-secondary); padding: 2rem;">
                        Loading model history...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Card -->
    <div class="card">
        <h2 class="card-title">Training Status</h2>
        
        <!-- Model Name and Status -->
        <div class="mb-4">
            <div id="modelName" class="model-name no-select">-</div>
            <div id="modelStatus" class="model-status">Not training</div>
        </div>
        
        <!-- Metrics Grid - Mobile Responsive -->
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3">
            <div class="text-center md:text-left">
                <div id="currentEpoch" class="metric">-</div>
                <div class="metric-label">Current Epoch</div>
            </div>
            <div class="text-center md:text-left">
                <div id="bestValLoss" class="metric">-</div>
                <div class="metric-label">Best Val Loss</div>
            </div>
            <div class="text-center md:text-left">
                <div id="currentTrainLoss" class="metric">-</div>
                <div class="metric-label">Train Loss</div>
            </div>
            <div class="text-center md:text-left">
                <div id="currentValLoss" class="metric">-</div>
                <div class="metric-label">Val Loss</div>
            </div>
            <div class="text-center md:text-left">
                <div id="avgEpochTime" class="metric">-</div>
                <div class="metric-label">Avg Epoch Time</div>
            </div>
            <div class="text-center md:text-left">
                <div id="samplesPerSec" class="metric">-</div>
                <div class="metric-label">Samples/sec</div>
            </div>
        </div>
    </div>

    <!-- Training Progress -->
    <div class="card">
        <h2 class="card-title">Training Progress</h2>
        <div id="lossPlot" class="plotly-container"></div>
    </div>

    <!-- Performance Metrics -->
    <div class="card">
        <h2 class="card-title">Performance Metrics</h2>
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <div>
                <h3 class="text-base md:text-lg font-semibold mb-2" style="color: var(--text-primary);">Training Speed</h3>
                <div id="speedPlot" class="plotly-container"></div>
            </div>
            <div>
                <h3 class="text-base md:text-lg font-semibold mb-2" style="color: var(--text-primary);">Resource Usage</h3>
                <div id="resourcePlot" class="plotly-container"></div>
            </div>
        </div>
    </div>

    <!-- Model Architecture -->
    <div class="card">
        <h2 class="card-title">Model Architecture</h2>
        <div id="architectureDiagram" class="w-full overflow-x-auto">
            <div class="text-center text-gray-500 py-8">
                Loading architecture diagram...
            </div>
        </div>
    </div>

    <!-- Configuration -->
    <div class="card">
        <h2 class="card-title">Configuration</h2>
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <div class="config-section">
                <h3 class="text-base md:text-lg font-semibold mb-2" style="color: var(--text-primary);">Model Parameters</h3>
                <div id="modelConfigList" class="p-3 rounded text-sm" style="background-color: var(--bg-tertiary); color: var(--text-secondary);"></div>
            </div>
            <div class="config-section">
                <h3 class="text-base md:text-lg font-semibold mb-2" style="color: var(--text-primary);">Training Parameters</h3>
                <div id="trainingConfigList" class="p-3 rounded text-sm" style="background-color: var(--bg-tertiary); color: var(--text-secondary);"></div>
            </div>
        </div>
    </div>

    <script>
        function updatePlot(epochs, trainLosses, valLosses) {
            const trace1 = {
                x: epochs,
                y: trainLosses,
                name: 'Training Loss',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#2563eb', width: 2 }
            };

            const trace2 = {
                x: epochs,
                y: valLosses,
                name: 'Validation Loss',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#dc2626', width: 2 }
            };

            // Find best validation loss point
            let bestValLoss = Math.min(...valLosses);
            let bestEpoch = epochs[valLosses.indexOf(bestValLoss)];

            const trace3 = {
                x: [bestEpoch],
                y: [bestValLoss],
                name: `Best: ${bestValLoss.toFixed(6)}`,
                type: 'scatter',
                mode: 'markers',
                marker: {
                    color: 'gold',
                    size: 10,
                    symbol: 'star',
                    line: {
                        color: 'darkgoldenrod',
                        width: 2
                    }
                }
            };

            // Mobile-responsive layout
            const isMobile = window.innerWidth < 768;
            
            const layout = {
                title: {
                    text: 'Training History',
                    font: { size: isMobile ? 14 : 16 }
                },
                xaxis: { 
                    title: { 
                        text: 'Epoch',
                        font: { size: isMobile ? 12 : 14 }
                    },
                    tickfont: { size: isMobile ? 10 : 12 }
                },
                yaxis: { 
                    title: { 
                        text: 'Loss',
                        font: { size: isMobile ? 12 : 14 }
                    },
                    tickfont: { size: isMobile ? 10 : 12 }
                },
                margin: { 
                    t: isMobile ? 35 : 40,
                    l: isMobile ? 50 : 60,
                    r: isMobile ? 20 : 30,
                    b: isMobile ? 40 : 50
                },
                showlegend: true,
                legend: {
                    x: 0,
                    y: 1,
                    traceorder: 'normal',
                    orientation: isMobile ? 'v' : 'h',
                    font: { size: isMobile ? 10 : 12 },
                    bgcolor: 'rgba(255,255,255,0.8)'
                },
                // Mobile touch optimizations
                dragmode: isMobile ? 'pan' : 'zoom',
                scrollZoom: !isMobile
            };

            const config = {
                responsive: true,
                displayModeBar: !isMobile, // Hide toolbar on mobile for cleaner look
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'training_progress',
                    height: 500,
                    width: 700,
                    scale: 1
                }
            };

            // Set theme-aware colors
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const isDark = currentTheme === 'dark';
            layout.paper_bgcolor = isDark ? '#1f2937' : 'white';
            layout.plot_bgcolor = isDark ? '#1f2937' : 'white';
            layout.font = { color: isDark ? '#f9fafb' : '#1f2937' };
            
            // Update axis colors and grid for dark mode
            if (isDark) {
                layout.xaxis.gridcolor = '#4b5563';
                layout.xaxis.linecolor = '#6b7280';
                layout.xaxis.tickcolor = '#6b7280';
                layout.yaxis.gridcolor = '#4b5563';
                layout.yaxis.linecolor = '#6b7280';
                layout.yaxis.tickcolor = '#6b7280';
            } else {
                layout.xaxis.gridcolor = '#e5e7eb';
                layout.xaxis.linecolor = '#d1d5db';
                layout.xaxis.tickcolor = '#d1d5db';
                layout.yaxis.gridcolor = '#e5e7eb';
                layout.yaxis.linecolor = '#d1d5db';
                layout.yaxis.tickcolor = '#d1d5db';
            }
            
            // Update legend background for better contrast
            layout.legend.bgcolor = isDark ? 'rgba(55, 65, 81, 0.9)' : 'rgba(255,255,255,0.9)';
            layout.legend.bordercolor = isDark ? '#6b7280' : '#d1d5db';
            layout.legend.borderwidth = 1;

            Plotly.react('lossPlot', [trace1, trace2, trace3], layout, config);
        }

        function updatePerformancePlots(epochs, performance) {
            if (epochs.length === 0 || !performance) return;

            const isMobile = window.innerWidth < 768;
            
            // Training Speed Plot
            const speedTrace1 = {
                x: epochs,
                y: performance.samples_per_second || [],
                name: 'Samples/sec',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#10b981', width: 2 },
                marker: { size: 4 }
            };

            const speedTrace2 = {
                x: epochs,
                y: performance.epoch_durations || [],
                name: 'Epoch Time (s)',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#f59e0b', width: 2 },
                marker: { size: 4 },
                yaxis: 'y2'
            };

            const speedLayout = {
                title: {
                    text: 'Training Speed',
                    font: { size: isMobile ? 12 : 14 }
                },
                xaxis: { 
                    title: { 
                        text: 'Epoch',
                        font: { size: isMobile ? 10 : 12 }
                    },
                    tickfont: { size: isMobile ? 9 : 11 }
                },
                yaxis: { 
                    title: { 
                        text: 'Samples/sec',
                        font: { size: isMobile ? 10 : 12 }
                    },
                    tickfont: { size: isMobile ? 9 : 11 },
                    side: 'left'
                },
                yaxis2: {
                    title: { 
                        text: 'Time (s)',
                        font: { size: isMobile ? 10 : 12 }
                    },
                    tickfont: { size: isMobile ? 9 : 11 },
                    overlaying: 'y',
                    side: 'right'
                },
                margin: { 
                    t: isMobile ? 30 : 35,
                    l: isMobile ? 45 : 55,
                    r: isMobile ? 45 : 55,
                    b: isMobile ? 35 : 40
                },
                showlegend: true,
                legend: {
                    x: 0,
                    y: 1,
                    font: { size: isMobile ? 9 : 11 },
                    bgcolor: 'rgba(255,255,255,0.8)'
                },
                dragmode: isMobile ? 'pan' : 'zoom',
                scrollZoom: !isMobile
            };

            const speedConfig = {
                responsive: true,
                displayModeBar: !isMobile,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false
            };

            // Set theme-aware colors
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const isDark = currentTheme === 'dark';
            speedLayout.paper_bgcolor = isDark ? '#1f2937' : 'white';
            speedLayout.plot_bgcolor = isDark ? '#1f2937' : 'white';
            speedLayout.font = { color: isDark ? '#f9fafb' : '#1f2937' };
            
            // Update axis colors and grid for dark mode
            if (isDark) {
                speedLayout.xaxis.gridcolor = '#4b5563';
                speedLayout.xaxis.linecolor = '#6b7280';
                speedLayout.xaxis.tickcolor = '#6b7280';
                speedLayout.yaxis.gridcolor = '#4b5563';
                speedLayout.yaxis.linecolor = '#6b7280';
                speedLayout.yaxis.tickcolor = '#6b7280';
                speedLayout.yaxis2.gridcolor = '#4b5563';
                speedLayout.yaxis2.linecolor = '#6b7280';
                speedLayout.yaxis2.tickcolor = '#6b7280';
            } else {
                speedLayout.xaxis.gridcolor = '#e5e7eb';
                speedLayout.xaxis.linecolor = '#d1d5db';
                speedLayout.xaxis.tickcolor = '#d1d5db';
                speedLayout.yaxis.gridcolor = '#e5e7eb';
                speedLayout.yaxis.linecolor = '#d1d5db';
                speedLayout.yaxis.tickcolor = '#d1d5db';
                speedLayout.yaxis2.gridcolor = '#e5e7eb';
                speedLayout.yaxis2.linecolor = '#d1d5db';
                speedLayout.yaxis2.tickcolor = '#d1d5db';
            }
            
            // Update legend background for better contrast
            speedLayout.legend.bgcolor = isDark ? 'rgba(55, 65, 81, 0.9)' : 'rgba(255,255,255,0.9)';
            speedLayout.legend.bordercolor = isDark ? '#6b7280' : '#d1d5db';
            speedLayout.legend.borderwidth = 1;

            Plotly.react('speedPlot', [speedTrace1, speedTrace2], speedLayout, speedConfig);

            // Resource Usage Plot
            const resourceTrace1 = {
                x: epochs,
                y: performance.memory_usage || [],
                name: 'Memory (MB)',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#8b5cf6', width: 2 },
                marker: { size: 4 }
            };

            const resourceTrace2 = {
                x: epochs,
                y: performance.learning_rates || [],
                name: 'Learning Rate',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#ef4444', width: 2 },
                marker: { size: 4 },
                yaxis: 'y2'
            };

            const resourceLayout = {
                title: {
                    text: 'Resource Usage',
                    font: { size: isMobile ? 12 : 14 }
                },
                xaxis: { 
                    title: { 
                        text: 'Epoch',
                        font: { size: isMobile ? 10 : 12 }
                    },
                    tickfont: { size: isMobile ? 9 : 11 }
                },
                yaxis: { 
                    title: { 
                        text: 'Memory (MB)',
                        font: { size: isMobile ? 10 : 12 }
                    },
                    tickfont: { size: isMobile ? 9 : 11 },
                    side: 'left'
                },
                yaxis2: {
                    title: { 
                        text: 'Learning Rate',
                        font: { size: isMobile ? 10 : 12 }
                    },
                    tickfont: { size: isMobile ? 9 : 11 },
                    overlaying: 'y',
                    side: 'right',
                    type: 'log'
                },
                margin: { 
                    t: isMobile ? 30 : 35,
                    l: isMobile ? 45 : 55,
                    r: isMobile ? 45 : 55,
                    b: isMobile ? 35 : 40
                },
                showlegend: true,
                legend: {
                    x: 0,
                    y: 1,
                    font: { size: isMobile ? 9 : 11 },
                    bgcolor: 'rgba(255,255,255,0.8)'
                },
                dragmode: isMobile ? 'pan' : 'zoom',
                scrollZoom: !isMobile
            };

            const resourceConfig = {
                responsive: true,
                displayModeBar: !isMobile,
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                displaylogo: false
            };

            // Set theme-aware colors  
            resourceLayout.paper_bgcolor = isDark ? '#1f2937' : 'white';
            resourceLayout.plot_bgcolor = isDark ? '#1f2937' : 'white';
            resourceLayout.font = { color: isDark ? '#f9fafb' : '#1f2937' };
            
            // Update axis colors and grid for dark mode
            if (isDark) {
                resourceLayout.xaxis.gridcolor = '#4b5563';
                resourceLayout.xaxis.linecolor = '#6b7280';
                resourceLayout.xaxis.tickcolor = '#6b7280';
                resourceLayout.yaxis.gridcolor = '#4b5563';
                resourceLayout.yaxis.linecolor = '#6b7280';
                resourceLayout.yaxis.tickcolor = '#6b7280';
                resourceLayout.yaxis2.gridcolor = '#4b5563';
                resourceLayout.yaxis2.linecolor = '#6b7280';
                resourceLayout.yaxis2.tickcolor = '#6b7280';
            } else {
                resourceLayout.xaxis.gridcolor = '#e5e7eb';
                resourceLayout.xaxis.linecolor = '#d1d5db';
                resourceLayout.xaxis.tickcolor = '#d1d5db';
                resourceLayout.yaxis.gridcolor = '#e5e7eb';
                resourceLayout.yaxis.linecolor = '#d1d5db';
                resourceLayout.yaxis.tickcolor = '#d1d5db';
                resourceLayout.yaxis2.gridcolor = '#e5e7eb';
                resourceLayout.yaxis2.linecolor = '#d1d5db';
                resourceLayout.yaxis2.tickcolor = '#d1d5db';
            }
            
            // Update legend background for better contrast
            resourceLayout.legend.bgcolor = isDark ? 'rgba(55, 65, 81, 0.9)' : 'rgba(255,255,255,0.9)';
            resourceLayout.legend.bordercolor = isDark ? '#6b7280' : '#d1d5db';
            resourceLayout.legend.borderwidth = 1;

            Plotly.react('resourcePlot', [resourceTrace1, resourceTrace2], resourceLayout, resourceConfig);
        }

        function formatValue(value) {
            if (Array.isArray(value)) {
                return value.join(', ');
            } else if (typeof value === 'number') {
                return value.toString().includes('.') ? value.toFixed(6) : value;
            }
            return value;
        }

        function createConfigList(config, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            Object.entries(config).forEach(([key, value]) => {
                const row = document.createElement('div');
                row.className = 'mb-2 flex flex-col sm:flex-row sm:justify-between';

                const label = document.createElement('span');
                label.className = 'font-semibold text-xs sm:text-sm';
                label.style.color = 'var(--text-secondary)';
                label.textContent = key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

                const valueSpan = document.createElement('span');
                valueSpan.className = 'text-xs sm:text-sm break-all';
                valueSpan.style.color = 'var(--text-primary)';
                valueSpan.textContent = formatValue(value);

                row.appendChild(label);
                row.appendChild(valueSpan);
                container.appendChild(row);
            });
        }

        function updateMetrics(data) {
            const history = data.training_history;
            const lastEpoch = history.epochs[history.epochs.length - 1] || '-';
            const lastTrainLoss = history.train_losses[history.train_losses.length - 1]?.toFixed(6) || '-';
            const lastValLoss = history.val_losses[history.val_losses.length - 1]?.toFixed(6) || '-';
            const bestValLoss = history.best_val_loss?.toFixed(6) || '-';

            // Update model name and status
            const modelName = data.model_name || '-';
            document.getElementById('modelName').textContent = modelName.toUpperCase();
            
            // Update architecture diagram
            if (modelName !== '-') {
                updateArchitectureDiagram(modelName);
            }

            // Only update status if not viewing historical model (to preserve the historical indicator)
            if (!isViewingHistoricalModel) {
                const isTraining = history.epochs.length > 0 && !history.stopped_early;
                const statusText = isTraining ?
                    `Training - Epoch ${lastEpoch}/${data.training_config.num_epochs}` :
                    history.stopped_early ?
                        `Complete - Early stopped at epoch ${history.early_stopping_epoch}` :
                        'Not training';
                document.getElementById('modelStatus').textContent = statusText;
            }

            document.getElementById('currentEpoch').textContent = lastEpoch;
            document.getElementById('bestValLoss').textContent = bestValLoss;
            document.getElementById('currentTrainLoss').textContent = lastTrainLoss;
            document.getElementById('currentValLoss').textContent = lastValLoss;

            // Update performance metrics
            const performance = data.performance || {};
            const avgEpochTime = performance.avg_epoch_time ? `${performance.avg_epoch_time.toFixed(1)}s` : '-';
            const lastSamplesPerSec = performance.samples_per_second && performance.samples_per_second.length > 0 ? 
                performance.samples_per_second[performance.samples_per_second.length - 1].toFixed(0) : '-';
            
            document.getElementById('avgEpochTime').textContent = avgEpochTime;
            document.getElementById('samplesPerSec').textContent = lastSamplesPerSec;

            createConfigList(data.model_config, 'modelConfigList');
            createConfigList(data.training_config, 'trainingConfigList');

            if (history.epochs.length > 0) {
                updatePlot(history.epochs, history.train_losses, history.val_losses);
                updatePerformancePlots(history.epochs, data.performance);
            }
        }

        function fetchTrainingStatus() {
            // Only update if we're not viewing a historical model
            if (!isViewingHistoricalModel) {
                fetch('/api/training-status')
                    .then(response => response.json())
                    .then(data => {
                        updateMetrics(data);
                    })
                    .catch(error => console.error('Error fetching training status:', error));
            }
        }

        function fetchCurrentTrainingInfo() {
            // Always fetch current training info for the navigation indicator
            fetch('/api/current-training')
                .then(response => response.json())
                .then(data => {
                    updateNavigationIndicator(data);
                })
                .catch(error => console.error('Error fetching current training info:', error));
        }

        function updateNavigationIndicator(trainingInfo) {
            // Add a small indicator to the navigation bar showing current training status
            const navTitle = document.querySelector('.nav-title');
            const existingIndicator = document.querySelector('.training-indicator');
            
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            if (trainingInfo.is_training && trainingInfo.model_name) {
                const indicator = document.createElement('span');
                indicator.className = 'training-indicator';
                indicator.style.cssText = `
                    margin-left: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    background: var(--success-color);
                    color: white;
                    border-radius: 12px;
                    font-size: 0.75rem;
                    font-weight: 500;
                `;
                indicator.textContent = `${trainingInfo.model_name.toUpperCase()} Training`;
                navTitle.appendChild(indicator);
            }
        }

        // Handle window resize for plot responsiveness
        window.addEventListener('resize', function() {
            // Debounce resize events
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(function() {
                // Trigger plot update if data exists
                fetchTrainingStatus();
            }, 250);
        });

        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            themeVariables: {
                primaryColor: '#2563eb',
                primaryTextColor: '#1f2937',
                primaryBorderColor: '#3b82f6',
                lineColor: '#6b7280',
                secondaryColor: '#f3f4f6',
                tertiaryColor: '#ffffff'
            }
        });

        // Model architecture diagrams
        const architectureDiagrams = {
            'fnn': `
graph TD
    %% Input Layer
    A["Input Features<br/>8 coordinates<br/>StandardScaler"] --> B["Linear Layer 1<br/>8 to 64<br/>He Init"]
    
    %% First Hidden Layer
    B --> C["BatchNorm1d<br/>64 features"]
    C --> D["ReLU Activation"]
    D --> E["Dropout<br/>p=0.3"]
    
    %% Second Hidden Layer
    E --> F["Linear Layer 2<br/>64 to 32<br/>He Init"]
    F --> G["BatchNorm1d<br/>32 features"]
    G --> H["ReLU Activation"]
    H --> I["Dropout<br/>p=0.3"]
    
    %% Output Layer
    I --> J["Output Layer<br/>32 to 3<br/>Xavier Init<br/>gain=0.1"]
    J --> K["Output<br/>vx, vy, vz<br/>Inverse Scaler"]
    
    %% Styling
    classDef input fill:#e1f5fe
    classDef linear fill:#f3e5f5
    classDef norm fill:#e8f5e8
    classDef activation fill:#fff3e0
    classDef dropout fill:#ffebee
    classDef output fill:#e0f2f1
    
    class A input
    class B,F,J linear
    class C,G norm
    class D,H activation
    class E,I dropout
    class K output
            `,
            'lstm': `
graph TD
    %% Input Sequence
    A["Input Sequence<br/>Shape: batch,10,8<br/>StandardScaler"] --> B["LSTM Layer 1<br/>Input: 8<br/>Hidden: 64<br/>Bidirectional: False"]
    
    %% LSTM Layers
    B --> C["LSTM Layer 2<br/>Hidden: 64<br/>Dropout: 0.2<br/>between layers"]
    
    %% Sequence Output
    C --> D["LSTM Output<br/>Shape: batch,10,64<br/>All timesteps"]
    
    %% Last Timestep Selection
    D --> E["Last Timestep<br/>Shape: batch,64<br/>last output"]
    
    %% Fully Connected Layers
    E --> F["Linear Layer 1<br/>64 to 32"]
    F --> G["ReLU Activation"]
    G --> H["Dropout<br/>p=0.2"]
    H --> I["Linear Layer 2<br/>32 to 3"]
    I --> J["Output<br/>vx, vy, vz<br/>Inverse Scaler"]
    
    %% Styling
    classDef input fill:#e1f5fe
    classDef lstm fill:#f3e5f5
    classDef selection fill:#fff3e0
    classDef linear fill:#e8f5e8
    classDef activation fill:#fff3e0
    classDef dropout fill:#ffebee
    classDef output fill:#e0f2f1
    
    class A input
    class B,C lstm
    class D,E selection
    class F,I linear
    class G activation
    class H dropout
    class J output
            `,
            'resnet': `
graph TD
    %% Input Processing
    A["Input Features<br/>8 coordinates<br/>StandardScaler"] --> B["Input Projection<br/>Linear: 8 to 64"]
    B --> C["ReLU Activation"]
    C --> D["Dropout<br/>p=0.2"]
    
    %% Residual Block 1
    D --> E1["Linear: 64 to 64"]
    E1 --> E2["ReLU"]
    E2 --> E3["Dropout p=0.2"]
    E3 --> E4["Linear: 64 to 64"]
    E4 --> E5["ReLU"]
    E5 --> E6["Dropout p=0.2"]
    D --> E8["Add: x + residual"]
    E6 --> E8
    
    %% Residual Block 2
    E8 --> F1["Linear: 64 to 64"]
    F1 --> F2["ReLU"]
    F2 --> F3["Dropout p=0.2"]
    F3 --> F4["Linear: 64 to 64"]
    F4 --> F5["ReLU"]
    F5 --> F6["Dropout p=0.2"]
    E8 --> F8["Add: x + residual"]
    F6 --> F8
    
    %% Residual Block 3
    F8 --> G1["Linear: 64 to 64"]
    G1 --> G2["ReLU"]
    G2 --> G3["Dropout p=0.2"]
    G3 --> G4["Linear: 64 to 64"]
    G4 --> G5["ReLU"]
    G5 --> G6["Dropout p=0.2"]
    F8 --> G8["Add: x + residual"]
    G6 --> G8
    
    %% Output Projection
    G8 --> H["Output Projection<br/>Linear: 64 to 32"]
    H --> I["ReLU Activation"]
    I --> J["Dropout<br/>p=0.2"]
    J --> K["Final Layer<br/>Linear: 32 to 3"]
    K --> L["Output<br/>vx, vy, vz<br/>Inverse Scaler"]
    
    %% Styling
    classDef input fill:#e1f5fe
    classDef projection fill:#f3e5f5
    classDef activation fill:#fff3e0
    classDef dropout fill:#ffebee
    classDef add fill:#f1f8e9
    classDef output fill:#e0f2f1
    
    class A input
    class B,H,K projection
    class C,I activation
    class D,J dropout
    class E1,E4,F1,F4,G1,G4 projection
    class E2,E5,F2,F5,G2,G5 activation
    class E3,E6,F3,F6,G3,G6 dropout
    class E8,F8,G8 add
    class L output
            `,
            'hybrid': `
graph TD
    %% Input Processing
    A["Input Sequence<br/>Shape: batch,10,8<br/>StandardScaler"] --> B["Reshape for CNN<br/>batch*10,1,8"]
    
    %% CNN Feature Extraction
    B --> C["Conv1d Layer 1<br/>1 to 16 channels<br/>kernel=3, padding=1"]
    C --> D["ReLU Activation"]
    D --> E["MaxPool1d<br/>kernel=2, stride=2"]
    E --> F["Dropout<br/>p=0.2"]
    
    F --> G["Conv1d Layer 2<br/>16 to 32 channels<br/>kernel=3, padding=1"]
    G --> H["ReLU Activation"]
    H --> I["MaxPool1d<br/>kernel=2, stride=2"]
    I --> J["Dropout<br/>p=0.2"]
    
    %% Reshape for LSTM
    J --> K["Reshape for LSTM<br/>batch,10,features"]
    
    %% LSTM Processing
    K --> L["LSTM Layer 1<br/>Input: CNN_features<br/>Hidden: 64"]
    L --> M["LSTM Layer 2<br/>Hidden: 64<br/>Dropout: 0.2<br/>between layers"]
    
    %% Sequence Output
    M --> N["LSTM Output<br/>Shape: batch,10,64<br/>All timesteps"]
    N --> O["Last Timestep<br/>Shape: batch,64<br/>last output"]
    
    %% Fully Connected Head
    O --> P["Linear Layer 1<br/>64 to 32"]
    P --> Q["ReLU Activation"]
    Q --> R["Dropout<br/>p=0.2"]
    R --> S["Linear Layer 2<br/>32 to 3"]
    S --> T["Output<br/>vx, vy, vz<br/>Inverse Scaler"]
    
    %% Styling
    classDef input fill:#e1f5fe
    classDef reshape fill:#fff3e0
    classDef conv fill:#f3e5f5
    classDef activation fill:#fff3e0
    classDef pool fill:#e8f5e8
    classDef dropout fill:#ffebee
    classDef lstm fill:#f3e5f5
    classDef selection fill:#fff3e0
    classDef linear fill:#e8f5e8
    classDef output fill:#e0f2f1
    
    class A input
    class B,K reshape
    class C,G conv
    class D,H,Q activation
    class E,I pool
    class F,J,R dropout
    class L,M lstm
    class N,O selection
    class P,S linear
    class T output
            `
        };

        // Track the currently displayed model to avoid unnecessary re-renders
        let currentDisplayedModel = null;
        let currentSelectedModel = null;
        let availableModels = [];
        let isViewingHistoricalModel = false;

        function updateArchitectureDiagram(modelName) {
            const diagramContainer = document.getElementById('architectureDiagram');
            const modelKey = modelName.toLowerCase();
            
            // Only update if the model has changed
            if (currentDisplayedModel === modelKey) {
                return; // Skip re-rendering if same model
            }
            
            currentDisplayedModel = modelKey;
            
            if (architectureDiagrams[modelKey]) {
                // Clear the container completely
                diagramContainer.innerHTML = '';
                
                // Create a unique ID for this diagram
                const diagramId = 'mermaid-diagram-' + modelKey;
                const diagramDiv = document.createElement('div');
                diagramDiv.id = diagramId;
                diagramDiv.className = 'mermaid-diagram';
                diagramContainer.appendChild(diagramDiv);
                
                // Render the Mermaid diagram
                mermaid.render(diagramId + '-svg', architectureDiagrams[modelKey])
                    .then(result => {
                        const targetDiv = document.getElementById(diagramId);
                        if (targetDiv) {
                            targetDiv.innerHTML = result.svg;
                        }
                    })
                    .catch(error => {
                        console.error('Error rendering Mermaid diagram:', error);
                        diagramContainer.innerHTML = `
                            <div class="text-center text-red-500 py-8">
                                <p>Error loading architecture diagram</p>
                                <p class="text-sm text-gray-500 mt-2">Model: ${modelName}</p>
                            </div>
                        `;
                    });
            } else {
                diagramContainer.innerHTML = `
                    <div class="text-center text-gray-500 py-8">
                        <p>Architecture diagram not available</p>
                        <p class="text-sm mt-2">Model: ${modelName}</p>
                    </div>
                `;
            }
        }

        // History Modal Management
        function toggleHistoryModal() {
            const modal = document.getElementById('historyModal');
            const isActive = modal.classList.contains('active');
            
            if (isActive) {
                modal.classList.remove('active');
            } else {
                modal.classList.add('active');
                loadModelHistory();
            }
        }

        function loadModelHistory() {
            fetch('/api/model-history')
                .then(response => response.json())
                .then(data => {
                    availableModels = data.models || [];
                    renderModelList();
                })
                .catch(error => {
                    console.error('Error loading model history:', error);
                    document.getElementById('modelList').innerHTML = `
                        <div class="text-center" style="color: var(--error-color); padding: 2rem;">
                            Error loading model history
                        </div>
                    `;
                });
        }

        function renderModelList() {
            const modelList = document.getElementById('modelList');
            
            if (availableModels.length === 0) {
                modelList.innerHTML = `
                    <div class="text-center" style="color: var(--text-secondary); padding: 2rem;">
                        No model history found
                    </div>
                `;
                return;
            }

            modelList.innerHTML = availableModels.map(model => {
                const isActive = model.name === currentSelectedModel;
                const isTraining = model.status === 'training';
                
                return `
                    <div class="model-item ${isActive ? 'active' : ''}" onclick="selectModel('${model.name}')">
                        <div class="model-item-header">
                            <div class="model-item-name">${model.name.toUpperCase()}</div>
                            <div class="model-item-status ${isTraining ? 'training' : ''}">${model.status}</div>
                        </div>
                        <div class="model-item-details">
                            <div>Epochs: ${model.epochs || 'N/A'}</div>
                            <div>Best Loss: ${model.best_loss ? model.best_loss.toFixed(6) : 'N/A'}</div>
                            <div>Last Modified: ${model.last_modified || 'N/A'}</div>
                            <div>Final Loss: ${model.final_loss ? model.final_loss.toFixed(6) : 'N/A'}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function selectModel(modelName) {
            currentSelectedModel = modelName;
            isViewingHistoricalModel = true;
            renderModelList();
            
            // Load the selected model's data
            fetch(`/api/model-data/${modelName}`)
                .then(response => response.json())
                .then(data => {
                    updateMetrics(data);
                    updateModelStatusIndicator(modelName, 'historical');
                    toggleHistoryModal(); // Close modal after selection
                })
                .catch(error => {
                    console.error('Error loading model data:', error);
                });
        }

        function returnToCurrentTraining() {
            isViewingHistoricalModel = false;
            currentSelectedModel = null;
            fetchTrainingStatus();
        }

        function updateModelStatusIndicator(modelName, type) {
            const statusElement = document.getElementById('modelStatus');
            if (type === 'historical') {
                statusElement.innerHTML = `
                    <span style="color: var(--warning-color);">ðŸ“Š Viewing Historical Model</span>
                    <button onclick="returnToCurrentTraining()" 
                            style="margin-left: 1rem; padding: 0.25rem 0.5rem; background: var(--accent-color); color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">
                        Return to Current Training
                    </button>
                `;
            }
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('historyModal');
            if (event.target === modal) {
                toggleHistoryModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('historyModal');
                if (modal.classList.contains('active')) {
                    toggleHistoryModal();
                }
            }
        });

        // Theme management
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Update theme toggle button
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            
            if (newTheme === 'dark') {
                themeIcon.textContent = 'â˜€ï¸';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = 'ðŸŒ™';
                themeText.textContent = 'Dark';
            }
            
            // Save theme preference
            localStorage.setItem('theme', newTheme);
            
            // Update plot colors for current theme
            updatePlotsForTheme(newTheme);
        }

        function updatePlotsForTheme(theme) {
            const isDark = theme === 'dark';
            const bgColor = isDark ? '#1f2937' : '#ffffff';
            const textColor = isDark ? '#f9fafb' : '#1f2937';
            const gridColor = isDark ? '#4b5563' : '#e5e7eb';
            const lineColor = isDark ? '#6b7280' : '#d1d5db';
            const legendBg = isDark ? 'rgba(55, 65, 81, 0.9)' : 'rgba(255,255,255,0.9)';
            const legendBorder = isDark ? '#6b7280' : '#d1d5db';
            
            // Update existing plots if they exist
            const plots = document.querySelectorAll('.js-plotly-plot');
            plots.forEach(plot => {
                if (plot.layout) {
                    plot.layout.paper_bgcolor = bgColor;
                    plot.layout.plot_bgcolor = bgColor;
                    plot.layout.font = { color: textColor };
                    
                    // Update axis styling
                    if (plot.layout.xaxis) {
                        plot.layout.xaxis.gridcolor = gridColor;
                        plot.layout.xaxis.linecolor = lineColor;
                        plot.layout.xaxis.tickcolor = lineColor;
                        plot.layout.xaxis.title.font = { color: textColor };
                        plot.layout.xaxis.tickfont = { color: textColor };
                    }
                    if (plot.layout.yaxis) {
                        plot.layout.yaxis.gridcolor = gridColor;
                        plot.layout.yaxis.linecolor = lineColor;
                        plot.layout.yaxis.tickcolor = lineColor;
                        plot.layout.yaxis.title.font = { color: textColor };
                        plot.layout.yaxis.tickfont = { color: textColor };
                    }
                    if (plot.layout.yaxis2) {
                        plot.layout.yaxis2.gridcolor = gridColor;
                        plot.layout.yaxis2.linecolor = lineColor;
                        plot.layout.yaxis2.tickcolor = lineColor;
                        plot.layout.yaxis2.title.font = { color: textColor };
                        plot.layout.yaxis2.tickfont = { color: textColor };
                    }
                    
                    // Update legend styling
                    if (plot.layout.legend) {
                        plot.layout.legend.bgcolor = legendBg;
                        plot.layout.legend.bordercolor = legendBorder;
                        plot.layout.legend.borderwidth = 1;
                        plot.layout.legend.font = { color: textColor };
                    }
                    
                    // Update title color
                    if (plot.layout.title) {
                        plot.layout.title.font = { color: textColor };
                    }
                    
                    Plotly.redraw(plot);
                }
            });
        }

        // Initialize theme from localStorage or default to light
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            
            if (savedTheme === 'dark') {
                themeIcon.textContent = 'â˜€ï¸';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = 'ðŸŒ™';
                themeText.textContent = 'Dark';
            }
        }

        // Initialize theme on page load
        initializeTheme();

        // Initial fetch and setup periodic updates
        fetchTrainingStatus();
        fetchCurrentTrainingInfo();
        setInterval(fetchTrainingStatus, 1000);
        setInterval(fetchCurrentTrainingInfo, 2000); // Check current training status every 2 seconds

        // Print functionality
        function printReport() {
            // Add timestamp to the last card for print
            const lastCard = document.querySelector('.card:last-child');
            if (lastCard) {
                const timestamp = new Date().toLocaleString();
                lastCard.setAttribute('data-timestamp', timestamp);
            }
            
            // Trigger print dialog
            window.print();
        }

        // Keyboard shortcut for printing (Ctrl+P)
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'p') {
                event.preventDefault();
                printReport();
            }
        });

        // Optimize plots and diagrams for print before printing
        window.addEventListener('beforeprint', function() {
            // Force plots to use print-friendly settings
            const plots = document.querySelectorAll('.js-plotly-plot');
            plots.forEach(plot => {
                if (plot.layout) {
                    // Ensure white background for print
                    plot.layout.paper_bgcolor = 'white';
                    plot.layout.plot_bgcolor = 'white';
                    Plotly.redraw(plot);
                }
            });

            // Optimize Mermaid diagrams for print
            const mermaidDiagrams = document.querySelectorAll('.mermaid-diagram svg');
            mermaidDiagrams.forEach(svg => {
                // Force print-friendly styling
                svg.style.background = 'white';
                svg.style.maxWidth = '100%';
                svg.style.height = 'auto';
                svg.style.border = 'none';
                svg.style.boxShadow = 'none';
                
                // Ensure text is black and readable
                const textElements = svg.querySelectorAll('text');
                textElements.forEach(text => {
                    text.style.fill = 'black';
                    text.style.fontSize = '9pt';
                    text.style.fontFamily = 'Arial, sans-serif';
                });

                // Ensure shapes have proper borders
                const shapes = svg.querySelectorAll('rect, circle, ellipse, polygon');
                shapes.forEach(shape => {
                    shape.style.stroke = 'black';
                    shape.style.strokeWidth = '1pt';
                    shape.style.fill = 'white';
                });

                // Ensure lines are visible
                const paths = svg.querySelectorAll('path');
                paths.forEach(path => {
                    if (path.classList.contains('edgePath') || path.parentElement.classList.contains('edgePath')) {
                        path.style.stroke = 'black';
                        path.style.strokeWidth = '1pt';
                        path.style.fill = 'none';
                    }
                });
            });
        });

        // Prevent zoom on double tap for better mobile experience
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>

</html>